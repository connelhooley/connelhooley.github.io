<html lang=" en ">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Connel Hooley - Akka Guide</title>
  
  <link rel="stylesheet" href="/assets/css/reveal/reveal.css">
  <link rel="stylesheet" href="/assets/css/reveal/reveal-theme.css">
  

  <link rel="alternate" type="application/rss+xml" title="Connel Hooley" href="/feed.xml">  
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
  <link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
  <link rel="manifest" href="/manifest.json">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#f8bb15">
  <meta name="theme-color" content="#f8bb15">
  
  <script src="/assets/js/reveal/lib/head.min.js"></script>
  

  <!-- Begin Jekyll SEO tag v2.1.0 -->
<meta property="og:title" content="Akka Guide" />
<meta name="description" content="You can do it Put your Akka into it Akka is an implemenation of the &quot;actor model&quot; on .NET Port of the Scala Akka framework Open source project, Petabridge is one of the main contributors What is the actor model? It is a way of structuring your app Instead of classes calling each other directly, they communicate via messages by using a framework Classes that communicate in this manner are called Actors Actors have a message queue or inbox, from which they process one message at a time, thus making them thread safe. Actors can only talk to other actors via the sending of messages. When processing a message an actor can modify its own internal private state, but not the state of other actors. Why use an actor model? Actors process one message at a time and are therefore thread safe Actors have a great mechinism for error handling Actors have a great mechinism for asynchronus programming Distributing functionality amongst actors results in software that is extremely scalable and loosely coupled How the actor model relates to traditional code Think of an actor as a function and the message as its parameters. What the function does depends on the type of message it receives. When an actor sends a message to another actor, think of this as one function calling another. Actor Hierarchy An actor can create other actors The newly created actor is called the child actor The actor that created it is called the parent actor This results in a tree structure, which is great for error handling Actor Hierarchy When an actor&#39;s child throws an unhandled exception it must decide what to do. It has three options: Restart all its child actors Just restart the failing child actor Escalate the error to its parent actor, who in turn has to the same three options Starting your first actor If actors create other actors, how do I crete my first actor? Actor System using System; using Akka.Actor;" />
<meta property="og:description" content="You can do it Put your Akka into it Akka is an implemenation of the &quot;actor model&quot; on .NET Port of the Scala Akka framework Open source project, Petabridge is one of the main contributors What is the actor model? It is a way of structuring your app Instead of classes calling each other directly, they communicate via messages by using a framework Classes that communicate in this manner are called Actors Actors have a message queue or inbox, from which they process one message at a time, thus making them thread safe. Actors can only talk to other actors via the sending of messages. When processing a message an actor can modify its own internal private state, but not the state of other actors. Why use an actor model? Actors process one message at a time and are therefore thread safe Actors have a great mechinism for error handling Actors have a great mechinism for asynchronus programming Distributing functionality amongst actors results in software that is extremely scalable and loosely coupled How the actor model relates to traditional code Think of an actor as a function and the message as its parameters. What the function does depends on the type of message it receives. When an actor sends a message to another actor, think of this as one function calling another. Actor Hierarchy An actor can create other actors The newly created actor is called the child actor The actor that created it is called the parent actor This results in a tree structure, which is great for error handling Actor Hierarchy When an actor&#39;s child throws an unhandled exception it must decide what to do. It has three options: Restart all its child actors Just restart the failing child actor Escalate the error to its parent actor, who in turn has to the same three options Starting your first actor If actors create other actors, how do I crete my first actor? Actor System using System; using Akka.Actor;" />
<link rel="canonical" href="http://connelhooley.uk/presentations/akka-guide" />
<meta property="og:url" content="http://connelhooley.uk/presentations/akka-guide" />
<meta property="og:site_name" content="Connel Hooley" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-02-25T14:06:47+00:00" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@connel_dev" />
<meta name="twitter:creator" content="@connel_dev" />
<script type="application/ld+json">
{"@context": "http://schema.org",
"@type": "BlogPosting",
"headline": "Akka Guide",
"datePublished": "2017-02-25T14:06:47+00:00",
"description": "You can do it Put your Akka into it Akka is an implemenation of the &quot;actor model&quot; on .NET Port of the Scala Akka framework Open source project, Petabridge is one of the main contributors What is the actor model? It is a way of structuring your app Instead of classes calling each other directly, they communicate via messages by using a framework Classes that communicate in this manner are called Actors Actors have a message queue or inbox, from which they process one message at a time, thus making them thread safe. Actors can only talk to other actors via the sending of messages. When processing a message an actor can modify its own internal private state, but not the state of other actors. Why use an actor model? Actors process one message at a time and are therefore thread safe Actors have a great mechinism for error handling Actors have a great mechinism for asynchronus programming Distributing functionality amongst actors results in software that is extremely scalable and loosely coupled How the actor model relates to traditional code Think of an actor as a function and the message as its parameters. What the function does depends on the type of message it receives. When an actor sends a message to another actor, think of this as one function calling another. Actor Hierarchy An actor can create other actors The newly created actor is called the child actor The actor that created it is called the parent actor This results in a tree structure, which is great for error handling Actor Hierarchy When an actor&#39;s child throws an unhandled exception it must decide what to do. It has three options: Restart all its child actors Just restart the failing child actor Escalate the error to its parent actor, who in turn has to the same three options Starting your first actor If actors create other actors, how do I crete my first actor? Actor System using System; using Akka.Actor;",
"publisher": {"@type": "Organization",
"logo": {"@type": "ImageObject",
"url": "http://connelhooley.uk/assets/images/logo.png"}},
"url": "http://connelhooley.uk/presentations/akka-guide"}</script>
<!-- End Jekyll SEO tag -->

  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-57397582-1', 'auto');
  ga('send', 'pageview');

</script>
  

  
</head>


<body class="layout-presentation">
    <div class="reveal">
        <div class="slides" aria-label="Slides">
            <section>
    <h1>You can do it</h1>
    <img src="/assets/images/you-can-do-it.gif" />
    <h1>Put your Akka into it</h1>
</section>
<section>
    <section>
        <h1>Akka is an implemenation of the "actor model" on .NET</h1>
        <aside class="notes">
            <ul>
                <li>Port of the Scala Akka framework</li>
                <li>Open source project, Petabridge is one of the main contributors</li>
            </ul>
        </aside>
    </section>
    <section>
        <h1>What is the actor model?</h1>
        <ul>
            <li>It is a way of structuring your app</li>
            <li>Instead of classes calling each other directly, they communicate via <b>messages</b> by using a framework</li>
            <li>Classes that communicate in this manner are called <b>Actors</b></li>
        </ul>
        <aside class="notes">
            <ul>
                <li>Actors have a message queue or inbox, from which they process one message at a time, thus making them thread safe.</li>
                <li>Actors can only talk to other actors via the sending of messages.</li>
                <li>When processing a message an actor can modify its own internal private state, but not the state of other actors.</li>
            </ul>   
        </aside>
    </section>
    <section>
        <h1>Why use an actor model?</h1>
        <ul>
            <li>Actors process one message at a time and are therefore <b>thread safe</b></li>
            <li>Actors have a great mechinism for <b>error handling</b></li>
            <li>Actors have a great mechinism for <b>asynchronus programming</b></li>
            <li>Distributing functionality amongst actors results in software that is extremely <b>scalable</b> and loosely coupled</li>
        </ul>
    </section>
    <section>
        <h1>How the actor model relates to traditional code</h1>
        <ul>
            <li>Think of an actor as a function and the message as its parameters.</li>
            <li>What the function does depends on the type of message it receives.</li>
            <li>When an actor sends a message to another actor, think of this as one function calling another.</li>
        </ul>
    </section>
    <section>
        <h1>Actor Hierarchy</h1>
        <ul>
            <li>An actor can create other actors
                <ul>
                    <li>The newly created actor is called the <b>child</b> actor</li>
                    <li>The actor that created it is called the <b>parent</b> actor</li>
                </ul>
            </li>
        </ul>
        <aside class="notes">
            <ul>
                <li>This results in a tree structure, which is great for error handling</li>
             </ul>
        </aside>
    </section>
    <section>
        <h1>Actor Hierarchy</h1>
        <ul>
            <li>When an actor's child throws an unhandled exception it must decide what to do. It has three options:
                <ul>
                    <li>Restart all its child actors</li>
                    <li>Just restart the failing child actor</li>
                    <li>Escalate the error to its parent actor, who in turn has to the same three options</li>
                </ul>
            </li>
        </ul>
    </section>
</section>
<section>
    <section>
        <h1>Starting your first actor</h1>
        <p>If actors create other actors, how do I crete my first actor?</p>
    </section>
    <section>
        <h1>Actor System</h1>
        <pre><code data-trim>
            using System;
            using Akka.Actor;

            namespace AkkaExamples
            {
                internal class Program
                {
                    private static ActorSystem _system;

                    private static void Main(string[] args)
                    {
                        _system = ActorSystem.Create("example-name");
                        Console.CancelKeyPress += (sender, eventArgs) =>
                        {
                            eventArgs.Cancel = true; // Canceling the event prevents the process terminating too early
                            _system.Terminate();
                        };
                        _system.WhenTerminated.Wait();
                    }
                }
            }
        </code></pre>
        <aside class="notes">
            <ul>
                <li>One actor system per app</li>
                <li>Entry point to the actor system</li>
                <li>Systems talk to each other over a network, name is used for routing</li>
                <li>Do not used system constructor, most Akka classes have a “Create” instantiation method.</li>
            </ul>
        </aside>
    </section>
    <section>
        <h1>Actors in the Actor System</h1>
        <ul>
            <li>Actors created directly inside the Actor System are called <b>Root Actors</b> as they do not have a parent</li>
            <li>You can have multiple root actors</li>
        </ul>
        <aside class="notes">
            <ul>
                <li>Imagine a tree with multiple root nodes</li>
            </ul>
        </aside>
    </section>
</section>
<section>
    <section>
        <h1>Instantiating Actors</h1>
        <ul>
            <li>
                Instantiating/starting an actor in Akka can be done in one of two places:
                <ul>
                    <li>In the ActorSystem (for creating <i>root</i> actors)</li>
                    <li>Inside Actors (for creating <i>child</i> actors)</li>
                </ul>
            </li>
            <li>Both places expose the same function to acheive this</li>
        </ul>
    </section>
    <section>
        <h1>Actor Of</h1>
        <pre><code class="language-csharp" data-trim>
            using System;
            using Akka.Actor;

            namespace AkkaExamples
            {
                internal class Program
                {
                    private static ActorSystem _system;

                    private static void Main(string[] args)
                    {
                        _system = ActorSystem.Create("example-name");
                        Console.CancelKeyPress += (sender, eventArgs) =>
                        {
                            eventArgs.Cancel = true;
                            _system.Terminate();
                        };

                        //Create root actor
                        IActorRef rootActor = _system.ActorOf(Props.Create(() => new ExampleRootActor()), "example-root-actor-name");

                        _system.WhenTerminated.Wait();
                    }
                }
            }
        </code></pre>
        <aside class="notes">
            <ul>
                <li>
                    IActorRef
                    <ul>
                        <li>Is returned not actor type</li>
                        <li>Allows no access to internal state regardless of whether its public</li>
                        <li>Forces us to follow actor model correctly</li>
                        <li>When a failing actor restarts the reference is updated</li>
                    </ul>
                </li>
                <li>
                    Props
                    <ul>
                        <li>Takes an expression on how to create Actor</li>
                        <li>Akka uses the expression to create actor</li>
                        <li>Used it to create new instances after failure</li>
                        <li>Hence why its an expression and not an instance of the actor object</li>
                    </ul>
                </li>
                <li>
                    Name
                    <ul>
                        <li>Used for routing</li>
                        <li>Optional (unlike system)</li>
                        <li>A GUID is used if one isn't given</li>
                        <li>Should be meaningful</li>
                        <li>No child of the same actor can have the same name</li>
                    </ul>
                </li>
            </ul>
        </aside>
    </section>
</section>
<section>
    <section>
        <h1>Sending Messages</h1>
        <pre><code class="language-csharp" data-trim>
            public class ExampleMessage
            {
                public ExampleMessage(string exampleData)
                {
                    ExampleData = exampleData;
                }

                public string ExampleData { get; }
            }
        </pre></code>
        <pre><code class="language-csharp" data-trim>
            IActorRef rootActor = _system.ActorOf(Props.Create(() => new ExampleRootActor()), "example-root-actor-name");
        
            //Send message to root actor via actor ref
            rootActor.Tell(new ExampleMessage("Example message information"));
        </pre></code>
        <aside class="notes">
            <ul>
                <li>Messages are
                    <ul>
                        <li>Simple POCO classes</li>
                        <li>Immutable</li>
                        <li>Serializable</li>
                        <li>Small (if large pass a handle)</li>
                    </ul>
                </li>
                <li>Tell is fire-and-forget, does not block thread, wait for response</li>
            </ul>
        </aside>
    </section>
</section>
<section>
    <section>
        <h1>Writing your own Actor</h1>
        <pre><code class="language-csharp" data-trim>
            public class ExampleRootActor : ReceiveActor
            {
                public ExampleRootActor()
                {
                    // Run the following lambda when a message is sent to this actor of type ExampleMessage
                    Receive&lt;ExampleMessage&gt;(m => ReceiveExampleMessage(m));
                }

                private void ReceiveExampleMessage(ExampleMessage exampleMessage)
                {
                    Console.WriteLine(exampleMessage.ExampleData);
                }

                public class ExampleMessage
                {
                    public ExampleMessage(string exampleData)
                    {
                        ExampleData = exampleData;
                    }

                    public string ExampleData { get; }
                }
            }
        </pre></code>
        <aside class="notes">
            <ul>
                <li>Inherit from ActorBase class</li>
                <li>Different classes are available for different extensions</li>
                <li>Give the actor a lambda to call for each type it receives (I'll call them receive callbacks)</li>
                <li>Private methods for each message type</li>
                <li>Ignore messages that have no callbacks</li>
                <li>First matching receive callback wins by default</li>
            </ul>
        </aside>
    </section>
</section>
<section>
    <section>
        <h1>Child Actors</h1>
        <pre><code class="language-csharp" data-trim>
            public class ExampleRootActor : ReceiveActor
            {
                private readonly IActorRef _exampleActorRef;

                public ExampleRootActor()
                {
                    // Create child actor
                    _exampleActorRef = Context.ActorOf(Props.Create(() => new ExampleChildActor()), "example-child-actor");
                    // Send child actor a message
                    _exampleActorRef.Tell(new ExampleMessage("Example message information"));
                }
            }
        </pre></code>
        <aside class="notes">
            <ul>
                <li>Context exposes same Actor Of method as system</li>
                <li>Context is populated by ActorOf method</li>
                <li>Another reason why actor handles the actual newing up for us</li>
            </ul>
        </aside>
    </section>
</section>
<section>
    <section>
        <h1>Sending messages to parent</h1>
        <pre><code class="language-csharp" data-trim>
            public class ExampleChildActor : ReceiveActor
            {
                public ExampleChildActor()
                {
                    Receive&lt;ExampleMessage&gt;(m => ReceiveExampleMessage(m));
                }

                private void ReceiveExampleMessage(ExampleMessage exampleMessage)
                {
                    // Process message
                    Console.WriteLine(exampleMessage.ExampleData);

                    // Send a new message to parent actor
                    Context.Parent.Tell(new ExampleSuccessMessage());
                }

                public class ExampleSuccessMessage { }
            }
        </pre></code>
    </section>
    <section>
        <h1>Sending messages to self</h1>
        <pre><code class="language-csharp" data-trim>
            public class ExampleChildActor : ReceiveActor
            {
                public ExampleChildActor()
                {
                    Receive&lt;ExampleMessage&gt;(m => ReceiveExampleMessage(m));
                    Receive&lt;ExampleSelfMessage&gt;(m => ReceiveExampleSelfMessage(m));
                }

                private void ReceiveExampleMessage(ExampleMessage exampleMessage)
                {
                    // Process message
                    Console.WriteLine(exampleMessage.ExampleData);
                    
                    // Send a new message to self
                    Self.Tell(new ExampleSelfMessage());
                }

                private void ReceiveExampleSelfMessage(ExampleSelfMessage exampleSelfMessage)
                {
                    // TODO Process message sent to self here
                }

                public class ExampleMessage
                {
                    public ExampleMessage(string exampleData)
                    {
                        ExampleData = exampleData;
                    }

                    public string ExampleData { get; }
                }

                public class ExampleSelfMessage { }
            }
        </pre></code>
        <aside class="notes">
            <ul>
                <li>Puts message at back of queue</li>
                <li>Allows actor to process other messages in the mean time</li>
                <li>Actors don't differenciate between messages sent from other actors or themselves</li>
                <li>Nesting classes inside actors allows them to be private</li>
            </ul>
        </aside>
    </section>
</section>
<section>
    <section>
        <h1>Replying to messages</h1>
        <pre><code class="language-csharp" data-trim>
            public class ExampleChildActor : ReceiveActor
            {
                public ExampleChildActor()
                {
                    Receive&lt;ExampleMessage&gt;(m => ReceiveExampleMessage(m));
                    Receive&lt;ExampleSelfMessage&gt;(m => ReceiveExampleSelfMessage(m));
                }

                private void ReceiveExampleMessage(ExampleMessage exampleMessage)
                {
                    // Process message
                    Console.WriteLine(exampleMessage.ExampleData);
                    
                    // Send a new message to self
                    Self.Tell(new ExampleSelfMessage());
                }

                private void ReceiveExampleSelfMessage(ExampleSelfMessage exampleSelfMessage)
                {
                    // TODO Process message sent to self here
                }

                public class ExampleMessage
                {
                    public ExampleMessage(string exampleData)
                    {
                        ExampleData = exampleData;
                    }

                    public string ExampleData { get; }
                }

                public class ExampleSelfMessage { }
            }
        </pre></code>
        <aside class="notes">
            <ul>
                <li>Send message to the actor that sent the message to you</li>
                <li>Use Context.Sender</li>
            </ul>
        </aside>
    </section>
    <section>
        <h1>Receiving Replies</h1>
        <pre><code class="language-csharp" data-trim>
            public class ExampleParentActor : ReceiveActor
            {
                private readonly IActorRef _exampleAskActorRef;

                public ExampleParentActor()
                {
                    ReceiveAsync&lt;Print&gt;(ReceivePrintAsync);
                    _exampleAskActorRef = Context.ActorOf(Props.Create(() => new ExampleAskActor()), "example-ask-actor-name");
                }

                private async Task ReceivePrintAsync(Print start)
                {
                    ExampleAskActor.ExampleResponseMessage result = await _exampleAskActorRef.Ask&lt;ExampleAskActor.ExampleResponseMessage&gt;(new ExampleAskActor.ExampleRequestMessage("Hello, World"));

                    // The following will print "Successfully replying to message: Hello, World"
                    Console.WriteLine(result.ExampleData);
                }

                public class Print { }
            }
            
            public class ExampleAskActor : ReceiveActor
            {
                public ExampleAskActor()
                {
                    Receive&lt;ExampleRequestMessage&gt;(m => ReceiveExampleRequestMessage(m));
                }
                
                private void ReceiveExampleRequestMessage(ExampleRequestMessage exampleMessage)
                {
                    // Reply to message
                    Context.Sender.Tell(new ExampleResponseMessage($"Successfully replying to message: {exampleMessage.ExampleData}"));
                }

                public class ExampleRequestMessage
                {
                    public ExampleRequestMessage(string exampleData)
                    {
                        ExampleData = exampleData;
                    }

                    public string ExampleData { get; }
                }

                public class ExampleResponseMessage
                {
                    public ExampleResponseMessage(string exampleData)
                    {
                        ExampleData = exampleData;
                    }

                    public string ExampleData { get; }
                }
            }
        </pre></code>
        <aside class="notes">
            <ul>
                <li>Aks method creates a task that resolves when message of requested type is replied</li>
                <li>Note use of ReceiveAsync</li>
                <li>Don't have to use ask, you can receive replied messages just like any other message</li>
            </ul>
        </aside>
    </section>    
</section>
<section>
    <section>
        <h1>Behaviours</h1>
        <pre><code class="language-csharp" data-trim>
            public class ExampleBehaviorActor : ReceiveActor
            {
                public ExampleBehaviorActor()
                {
                    Become(Starting);
                }

                private void Starting()
                {
                    Receive&lt;ExampleMessageType1&gt;(m => ReceiveExampleMessageType1(m));
                }

                private void Started()
                {
                    Receive&lt;ExampleMessageType2&gt;(m => ReceiveExampleMessageType2(m));
                }
                
                private void ReceiveExampleMessageType1(ExampleMessageType1 exampleMessage)
                {
                    //TODO: do something with first message type that would make actor ready for second message type
                    Become(Started);
                }
                private void ReceiveExampleMessageType2(ExampleMessageType2 exampleMessage)
                {
                    //TODO: do something with second message type
                }

                public class ExampleMessageType1 { }

                public class ExampleMessageType2 { }
            }
        </code></pre>
        <aside class="notes">
            <ul>
                <li>Change receive callbacks at run time</li>
                <li>Use Become method</li>
                <li>Note that receive callbacks are not carried over to new behaviors</li>
            </ul>
        </aside>
    </section>
    <section>
        <h1>Stashing</h1>
        <pre><code class="language-csharp" data-trim>
            public class ExampleStashActor : ReceiveActor, IWithUnboundedStash
            {
                public IStash Stash { get; set; } // Property to implement IWithUnboundedStash

                public ExampleStashActor()
                {
                    Become(Starting);
                }

                private void Starting()
                {
                    Receive&lt;ExampleMessageType1&gt;(m => ReceiveExampleMessageType1(m));
                    Receive&lt;ExampleMessageType2&gt;(m => Stash.Stash()); // Stash ExampleMessageType2 when starting
                }

                private void Started()
                {
                    Receive&lt;ExampleMessageType2&gt;(m => ReceiveExampleMessageType2(m));
                    Stash.UnstashAll(); // Unstash stashed messages when started
                }

                private void ReceiveExampleMessageType1(ExampleMessageType1 exampleMessage)
                {
                    //TODO: do something with first message type that would make actor ready for second message type
                    Become(Started);
                }
                private void ReceiveExampleMessageType2(ExampleMessageType2 exampleMessage)
                {
                    //TODO: do something with second message type
                }

                public class ExampleMessageType1 { }

                public class ExampleMessageType2 { }
            }
        </code></pre>
        <aside class="notes">
            <ul>
                <li>Often used with behaviors</li>
                <li>In memory list of messages</li>
                <li>Implement IWithUnboundedStash</li>
                <li>Stash is populated by ActorOf</li>
                <li>Stash method puts current message in stash</li>
                <li>Unstash method keeps message order and places them at the front of the queue</li>
            </ul>
        </aside>
    </section>
</section>

        </div>
    </div>
    <script src="/assets/js/reveal/reveal.js"></script>
    <script>
        Reveal.initialize({
            dependencies: [
                {
                    src: '/assets/js/reveal/lib/classList.js',
                    condition: function () {
                        return !document.body.classList;
                    }
                },
                {
                    src: '/assets/js/reveal/plugin/markdown/marked.js',
                    condition: function () {
                        return !!document.querySelector('[data-markdown]');
                    }
                },
                {
                    src: '/assets/js/reveal/plugin/markdown/markdown.js',
                    condition: function () {
                        return !!document.querySelector('[data-markdown]');
                    }
                },
                { 
                    src: '/assets/js/reveal/plugin/highlight/highlight.js', 
                    async: true, 
                    condition: function () { 
                        return !!document.querySelector('pre code'); 
                    }, 
                    callback: function () { 
                        hljs.initHighlightingOnLoad(); 
                    } 
                },
                { 
                    src: '/assets/js/reveal/plugin/zoom-js/zoom.js', 
                    async: true 
                },
                { 
                    src: '/assets/js/reveal/plugin/notes/notes.js', 
                    async: true 
                }
            ]
        });
    </script>
</body>
</html>